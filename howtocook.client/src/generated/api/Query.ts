//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../api';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);

export type Areas2QueryParameters = {
  id: number ;
}

export type CategoriesQueryParameters = {
  search: string | undefined ;
}

export type Categories2QueryParameters = {
  id: number ;
}

export type IngredientsQueryParameters = {
  id: number ;
}

export type RecipesQueryParameters = {
  category: number | undefined ;
  area: number | undefined ;
  skip: number | undefined ;
  limit: number | undefined ;
  search: string | undefined ;
}

export type Recipes2QueryParameters = {
  id: number ;
}

export type RandomQueryParameters = {
  count: number | undefined ;
}

export function areasUrl(): string {
  let url_ = getBaseUrl() + "/api/Areas";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let areasDefaultOptions: Omit<UseQueryOptions<Types.AreaListResponse, unknown, Types.AreaListResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AreaListResponse, unknown, Types.AreaListResponse>, 'queryFn'>> = {
};
export function getAreasDefaultOptions() {
  return areasDefaultOptions;
};
export function setAreasDefaultOptions(options: typeof areasDefaultOptions) {
  areasDefaultOptions = options;
}

export function areasQueryKey(): QueryKey;
export function areasQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'areas',
    ]);
}
export function __areas(context: QueryFunctionContext) {
  return Client().areas(
    );
}

/**
 * @return OK
 */
export function useAreasQuery<TSelectData = Types.AreaListResponse, TError = unknown>(options?: Omit<UseQueryOptions<Types.AreaListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useAreasQuery<TSelectData = Types.AreaListResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AreaListResponse, TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AreaListResponse, TError, TSelectData>({
    queryFn: __areas,
    queryKey: areasQueryKey(),
    ...areasDefaultOptions as unknown as Omit<UseQueryOptions<Types.AreaListResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAreasData(queryClient: QueryClient, updater: (data: Types.AreaListResponse | undefined) => Types.AreaListResponse, ) {
  queryClient.setQueryData(areasQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setAreasDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AreaListResponse | undefined) => Types.AreaListResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function areas2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/Areas/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let areas2DefaultOptions: Omit<UseQueryOptions<Types.AreaResponse, unknown, Types.AreaResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AreaResponse, unknown, Types.AreaResponse>, 'queryFn'>> = {
};
export function getAreas2DefaultOptions() {
  return areas2DefaultOptions;
};
export function setAreas2DefaultOptions(options: typeof areas2DefaultOptions) {
  areas2DefaultOptions = options;
}

export function areas2QueryKey(id: number): QueryKey;
export function areas2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Areas2QueryParameters;

    return trimArrayEnd([
        'Client',
        'areas2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'areas2',
        ...params
      ]);
  }
}
export function __areas2(context: QueryFunctionContext) {
  return Client().areas2(
      context.queryKey[2] as number    );
}

export function useAreas2Query<TSelectData = Types.AreaResponse, TError = unknown>(dto: Areas2QueryParameters, options?: Omit<UseQueryOptions<Types.AreaResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useAreas2Query<TSelectData = Types.AreaResponse, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.AreaResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useAreas2Query<TSelectData = Types.AreaResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AreaResponse, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Areas2QueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AreaResponse, TError, TSelectData>({
    queryFn: __areas2,
    queryKey: areas2QueryKey(id),
    ...areas2DefaultOptions as unknown as Omit<UseQueryOptions<Types.AreaResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAreas2Data(queryClient: QueryClient, updater: (data: Types.AreaResponse | undefined) => Types.AreaResponse, id: number) {
  queryClient.setQueryData(areas2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setAreas2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AreaResponse | undefined) => Types.AreaResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function categoriesUrl(search: string | undefined): string {
  let url_ = getBaseUrl() + "/api/Categories?";
if (search === null)
    throw new Error("The parameter 'search' cannot be null.");
else if (search !== undefined)
    url_ += "search=" + encodeURIComponent("" + search) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let categoriesDefaultOptions: Omit<UseQueryOptions<Types.CategoryListResponse, unknown, Types.CategoryListResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CategoryListResponse, unknown, Types.CategoryListResponse>, 'queryFn'>> = {
};
export function getCategoriesDefaultOptions() {
  return categoriesDefaultOptions;
};
export function setCategoriesDefaultOptions(options: typeof categoriesDefaultOptions) {
  categoriesDefaultOptions = options;
}

export function categoriesQueryKey(search: string | undefined): QueryKey;
export function categoriesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { search,  } = params[0] as CategoriesQueryParameters;

    return trimArrayEnd([
        'Client',
        'categories',
        search as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'categories',
        ...params
      ]);
  }
}
export function __categories(context: QueryFunctionContext) {
  return Client().categories(
      context.queryKey[2] as string | undefined    );
}

export function useCategoriesQuery<TSelectData = Types.CategoryListResponse, TError = unknown>(dto: CategoriesQueryParameters, options?: Omit<UseQueryOptions<Types.CategoryListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @param search (optional) 
 * @return OK
 */
export function useCategoriesQuery<TSelectData = Types.CategoryListResponse, TError = unknown>(search: string | undefined, options?: Omit<UseQueryOptions<Types.CategoryListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useCategoriesQuery<TSelectData = Types.CategoryListResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CategoryListResponse, TError, TSelectData> | undefined = undefined;
  let search: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ search,  } = params[0] as CategoriesQueryParameters);
      options = params[1];
    } else {
      [search, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CategoryListResponse, TError, TSelectData>({
    queryFn: __categories,
    queryKey: categoriesQueryKey(search),
    ...categoriesDefaultOptions as unknown as Omit<UseQueryOptions<Types.CategoryListResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param search (optional) 
 * @return OK
 */
export function setCategoriesData(queryClient: QueryClient, updater: (data: Types.CategoryListResponse | undefined) => Types.CategoryListResponse, search: string | undefined) {
  queryClient.setQueryData(categoriesQueryKey(search),
    updater
  );
}

/**
 * @param search (optional) 
 * @return OK
 */
export function setCategoriesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CategoryListResponse | undefined) => Types.CategoryListResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function categories2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/Categories/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let categories2DefaultOptions: Omit<UseQueryOptions<Types.CategoryResponse, unknown, Types.CategoryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CategoryResponse, unknown, Types.CategoryResponse>, 'queryFn'>> = {
};
export function getCategories2DefaultOptions() {
  return categories2DefaultOptions;
};
export function setCategories2DefaultOptions(options: typeof categories2DefaultOptions) {
  categories2DefaultOptions = options;
}

export function categories2QueryKey(id: number): QueryKey;
export function categories2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Categories2QueryParameters;

    return trimArrayEnd([
        'Client',
        'categories2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'categories2',
        ...params
      ]);
  }
}
export function __categories2(context: QueryFunctionContext) {
  return Client().categories2(
      context.queryKey[2] as number    );
}

export function useCategories2Query<TSelectData = Types.CategoryResponse, TError = unknown>(dto: Categories2QueryParameters, options?: Omit<UseQueryOptions<Types.CategoryResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useCategories2Query<TSelectData = Types.CategoryResponse, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.CategoryResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useCategories2Query<TSelectData = Types.CategoryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CategoryResponse, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Categories2QueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CategoryResponse, TError, TSelectData>({
    queryFn: __categories2,
    queryKey: categories2QueryKey(id),
    ...categories2DefaultOptions as unknown as Omit<UseQueryOptions<Types.CategoryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setCategories2Data(queryClient: QueryClient, updater: (data: Types.CategoryResponse | undefined) => Types.CategoryResponse, id: number) {
  queryClient.setQueryData(categories2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setCategories2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CategoryResponse | undefined) => Types.CategoryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function ingredientsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/Ingredients";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let ingredientsAllDefaultOptions: Omit<UseQueryOptions<Types.Ingredient[], unknown, Types.Ingredient[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Ingredient[], unknown, Types.Ingredient[]>, 'queryFn'>> = {
};
export function getIngredientsAllDefaultOptions() {
  return ingredientsAllDefaultOptions;
};
export function setIngredientsAllDefaultOptions(options: typeof ingredientsAllDefaultOptions) {
  ingredientsAllDefaultOptions = options;
}

export function ingredientsAllQueryKey(): QueryKey;
export function ingredientsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'ingredientsAll',
    ]);
}
export function __ingredientsAll(context: QueryFunctionContext) {
  return Client().ingredientsAll(
    );
}

/**
 * @return OK
 */
export function useIngredientsAllQuery<TSelectData = Types.Ingredient[], TError = unknown>(options?: Omit<UseQueryOptions<Types.Ingredient[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useIngredientsAllQuery<TSelectData = Types.Ingredient[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Ingredient[], TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Ingredient[], TError, TSelectData>({
    queryFn: __ingredientsAll,
    queryKey: ingredientsAllQueryKey(),
    ...ingredientsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.Ingredient[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setIngredientsAllData(queryClient: QueryClient, updater: (data: Types.Ingredient[] | undefined) => Types.Ingredient[], ) {
  queryClient.setQueryData(ingredientsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setIngredientsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Ingredient[] | undefined) => Types.Ingredient[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function ingredientsUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/Ingredients/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let ingredientsDefaultOptions: Omit<UseQueryOptions<Types.Ingredient, unknown, Types.Ingredient>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Ingredient, unknown, Types.Ingredient>, 'queryFn'>> = {
};
export function getIngredientsDefaultOptions() {
  return ingredientsDefaultOptions;
};
export function setIngredientsDefaultOptions(options: typeof ingredientsDefaultOptions) {
  ingredientsDefaultOptions = options;
}

export function ingredientsQueryKey(id: number): QueryKey;
export function ingredientsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as IngredientsQueryParameters;

    return trimArrayEnd([
        'Client',
        'ingredients',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'ingredients',
        ...params
      ]);
  }
}
export function __ingredients(context: QueryFunctionContext) {
  return Client().ingredients(
      context.queryKey[2] as number    );
}

export function useIngredientsQuery<TSelectData = Types.Ingredient, TError = unknown>(dto: IngredientsQueryParameters, options?: Omit<UseQueryOptions<Types.Ingredient, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useIngredientsQuery<TSelectData = Types.Ingredient, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.Ingredient, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useIngredientsQuery<TSelectData = Types.Ingredient, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Ingredient, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as IngredientsQueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Ingredient, TError, TSelectData>({
    queryFn: __ingredients,
    queryKey: ingredientsQueryKey(id),
    ...ingredientsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Ingredient, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setIngredientsData(queryClient: QueryClient, updater: (data: Types.Ingredient | undefined) => Types.Ingredient, id: number) {
  queryClient.setQueryData(ingredientsQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setIngredientsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Ingredient | undefined) => Types.Ingredient) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function recipesUrl(category: number | undefined, area: number | undefined, skip: number | undefined, limit: number | undefined, search: string | undefined): string {
  let url_ = getBaseUrl() + "/api/Recipes?";
if (category === null)
    throw new Error("The parameter 'category' cannot be null.");
else if (category !== undefined)
    url_ += "Category=" + encodeURIComponent("" + category) + "&";
if (area === null)
    throw new Error("The parameter 'area' cannot be null.");
else if (area !== undefined)
    url_ += "Area=" + encodeURIComponent("" + area) + "&";
if (skip === null)
    throw new Error("The parameter 'skip' cannot be null.");
else if (skip !== undefined)
    url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
if (search === null)
    throw new Error("The parameter 'search' cannot be null.");
else if (search !== undefined)
    url_ += "search=" + encodeURIComponent("" + search) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let recipesDefaultOptions: Omit<UseQueryOptions<Types.RecipeListResponse, unknown, Types.RecipeListResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RecipeListResponse, unknown, Types.RecipeListResponse>, 'queryFn'>> = {
};
export function getRecipesDefaultOptions() {
  return recipesDefaultOptions;
};
export function setRecipesDefaultOptions(options: typeof recipesDefaultOptions) {
  recipesDefaultOptions = options;
}

export function recipesQueryKey(dto: RecipesQueryParameters): QueryKey;
export function recipesQueryKey(category: number | undefined, area: number | undefined, skip: number | undefined, limit: number | undefined, search: string | undefined): QueryKey;
export function recipesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { category, area, skip, limit, search,  } = params[0] as RecipesQueryParameters;

    return trimArrayEnd([
        'Client',
        'recipes',
        category as any,
        area as any,
        skip as any,
        limit as any,
        search as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'recipes',
        ...params
      ]);
  }
}
export function __recipes(context: QueryFunctionContext) {
  return Client().recipes(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as string | undefined    );
}

export function useRecipesQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(dto: RecipesQueryParameters, options?: Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @param category (optional) 
 * @param area (optional) 
 * @param skip (optional) 
 * @param limit (optional) 
 * @param search (optional) 
 * @return OK
 */
export function useRecipesQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(category: number | undefined, area: number | undefined, skip: number | undefined, limit: number | undefined, search: string | undefined, options?: Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useRecipesQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RecipeListResponse, TError, TSelectData> | undefined = undefined;
  let category: any = undefined;
  let area: any = undefined;
  let skip: any = undefined;
  let limit: any = undefined;
  let search: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ category, area, skip, limit, search,  } = params[0] as RecipesQueryParameters);
      options = params[1];
    } else {
      [category, area, skip, limit, search, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RecipeListResponse, TError, TSelectData>({
    queryFn: __recipes,
    queryKey: recipesQueryKey(category, area, skip, limit, search),
    ...recipesDefaultOptions as unknown as Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param category (optional) 
 * @param area (optional) 
 * @param skip (optional) 
 * @param limit (optional) 
 * @param search (optional) 
 * @return OK
 */
export function setRecipesData(queryClient: QueryClient, updater: (data: Types.RecipeListResponse | undefined) => Types.RecipeListResponse, category: number | undefined, area: number | undefined, skip: number | undefined, limit: number | undefined, search: string | undefined) {
  queryClient.setQueryData(recipesQueryKey(category, area, skip, limit, search),
    updater
  );
}

/**
 * @param category (optional) 
 * @param area (optional) 
 * @param skip (optional) 
 * @param limit (optional) 
 * @param search (optional) 
 * @return OK
 */
export function setRecipesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RecipeListResponse | undefined) => Types.RecipeListResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function recipes2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/Recipes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let recipes2DefaultOptions: Omit<UseQueryOptions<Types.RecipeResponse, unknown, Types.RecipeResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RecipeResponse, unknown, Types.RecipeResponse>, 'queryFn'>> = {
};
export function getRecipes2DefaultOptions() {
  return recipes2DefaultOptions;
};
export function setRecipes2DefaultOptions(options: typeof recipes2DefaultOptions) {
  recipes2DefaultOptions = options;
}

export function recipes2QueryKey(id: number): QueryKey;
export function recipes2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Recipes2QueryParameters;

    return trimArrayEnd([
        'Client',
        'recipes2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'recipes2',
        ...params
      ]);
  }
}
export function __recipes2(context: QueryFunctionContext) {
  return Client().recipes2(
      context.queryKey[2] as number    );
}

export function useRecipes2Query<TSelectData = Types.RecipeResponse, TError = unknown>(dto: Recipes2QueryParameters, options?: Omit<UseQueryOptions<Types.RecipeResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useRecipes2Query<TSelectData = Types.RecipeResponse, TError = unknown>(id: number, options?: Omit<UseQueryOptions<Types.RecipeResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useRecipes2Query<TSelectData = Types.RecipeResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RecipeResponse, TError, TSelectData> | undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Recipes2QueryParameters);
      options = params[1];
    } else {
      [id, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RecipeResponse, TError, TSelectData>({
    queryFn: __recipes2,
    queryKey: recipes2QueryKey(id),
    ...recipes2DefaultOptions as unknown as Omit<UseQueryOptions<Types.RecipeResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setRecipes2Data(queryClient: QueryClient, updater: (data: Types.RecipeResponse | undefined) => Types.RecipeResponse, id: number) {
  queryClient.setQueryData(recipes2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setRecipes2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RecipeResponse | undefined) => Types.RecipeResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function randomUrl(count: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Recipes/random?";
if (count === null)
    throw new Error("The parameter 'count' cannot be null.");
else if (count !== undefined)
    url_ += "count=" + encodeURIComponent("" + count) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let randomDefaultOptions: Omit<UseQueryOptions<Types.RecipeListResponse, unknown, Types.RecipeListResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RecipeListResponse, unknown, Types.RecipeListResponse>, 'queryFn'>> = {
};
export function getRandomDefaultOptions() {
  return randomDefaultOptions;
};
export function setRandomDefaultOptions(options: typeof randomDefaultOptions) {
  randomDefaultOptions = options;
}

export function randomQueryKey(count: number | undefined): QueryKey;
export function randomQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { count,  } = params[0] as RandomQueryParameters;

    return trimArrayEnd([
        'Client',
        'random',
        count as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'random',
        ...params
      ]);
  }
}
export function __random(context: QueryFunctionContext) {
  return Client().random(
      context.queryKey[2] as number | undefined    );
}

export function useRandomQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(dto: RandomQueryParameters, options?: Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
/**
 * @param count (optional) 
 * @return OK
 */
export function useRandomQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(count: number | undefined, options?: Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useRandomQuery<TSelectData = Types.RecipeListResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RecipeListResponse, TError, TSelectData> | undefined = undefined;
  let count: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ count,  } = params[0] as RandomQueryParameters);
      options = params[1];
    } else {
      [count, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RecipeListResponse, TError, TSelectData>({
    queryFn: __random,
    queryKey: randomQueryKey(count),
    ...randomDefaultOptions as unknown as Omit<UseQueryOptions<Types.RecipeListResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param count (optional) 
 * @return OK
 */
export function setRandomData(queryClient: QueryClient, updater: (data: Types.RecipeListResponse | undefined) => Types.RecipeListResponse, count: number | undefined) {
  queryClient.setQueryData(randomQueryKey(count),
    updater
  );
}

/**
 * @param count (optional) 
 * @return OK
 */
export function setRandomDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RecipeListResponse | undefined) => Types.RecipeListResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getWeatherForecastUrl(): string {
  let url_ = getBaseUrl() + "/WeatherForecast";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getWeatherForecastDefaultOptions: Omit<UseQueryOptions<Types.WeatherForecast[], unknown, Types.WeatherForecast[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.WeatherForecast[], unknown, Types.WeatherForecast[]>, 'queryFn'>> = {
};
export function getGetWeatherForecastDefaultOptions() {
  return getWeatherForecastDefaultOptions;
};
export function setGetWeatherForecastDefaultOptions(options: typeof getWeatherForecastDefaultOptions) {
  getWeatherForecastDefaultOptions = options;
}

export function getWeatherForecastQueryKey(): QueryKey;
export function getWeatherForecastQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getWeatherForecast',
    ]);
}
export function __getWeatherForecast(context: QueryFunctionContext) {
  return Client().getWeatherForecast(
    );
}

/**
 * @return OK
 */
export function useGetWeatherForecastQuery<TSelectData = Types.WeatherForecast[], TError = unknown>(options?: Omit<UseQueryOptions<Types.WeatherForecast[], TError, TSelectData>, 'queryKey'>): UseQueryResult<TSelectData, TError>;
export function useGetWeatherForecastQuery<TSelectData = Types.WeatherForecast[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WeatherForecast[], TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.WeatherForecast[], TError, TSelectData>({
    queryFn: __getWeatherForecast,
    queryKey: getWeatherForecastQueryKey(),
    ...getWeatherForecastDefaultOptions as unknown as Omit<UseQueryOptions<Types.WeatherForecast[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setGetWeatherForecastData(queryClient: QueryClient, updater: (data: Types.WeatherForecast[] | undefined) => Types.WeatherForecast[], ) {
  queryClient.setQueryData(getWeatherForecastQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setGetWeatherForecastDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WeatherForecast[] | undefined) => Types.WeatherForecast[]) {
  queryClient.setQueryData(queryKey, updater);
}